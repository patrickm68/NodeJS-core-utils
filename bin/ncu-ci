#!/usr/bin/env node

'use strict';

const {
  PRBuild, BenchmarkRun, CommitBuild, parseJobFromURL,
  constants, JobParser, listBuilds
  // , jobCache
} = require('../lib/ci');
const clipboardy = require('clipboardy');
const { writeJson } = require('../lib/file');

const {
  PR, COMMIT, BENCHMARK
} = constants;

const { runPromise } = require('../lib/run');
const auth = require('../lib/auth');
const Request = require('../lib/request');
const CLI = require('../lib/cli');
const yargs = require('yargs');

// This is used for testing
// Default cache dir is ${ncu-source-dir}/.ncu/cache
// jobCache.enable();

// eslint-disable-next-line no-unused-vars
const argv = yargs
  .command({
    command: 'walk <type>',
    desc: 'Walk the CI and store the failures',
    builder: (yargs) => {
      yargs
        .positional('type', {
          describe: 'type of CI',
          choices: ['commit', 'pr']
        });
    },
    handler
  })
  .command({
    command: 'url <url>',
    desc: 'Automatically detect CI type and show results',
    builder: (yargs) => {
      yargs
        .positional('url', {
          describe: 'URL of the PR or the CI',
          type: 'string'
        });
    },
    handler
  })
  .command({
    command: 'pr <jobid>',
    desc: 'Show results of a node-test-pull-request CI job',
    builder: (yargs) => {
      yargs
        .positional('jobid', {
          describe: 'id of the job',
          type: 'number'
        });
    },
    handler
  })
  .command({
    command: 'commit <jobid>',
    desc: 'Show results of a node-test-commit CI job',
    builder: (yargs) => {
      yargs
        .positional('jobid', {
          describe: 'id of the job',
          type: 'number'
        });
    },
    handler
  })
  .command({
    command: 'benchmark <jobid>',
    desc: 'Show results of a benchmark-node-micro-benchmarks CI job',
    builder: (yargs) => {
      yargs
        .positional('jobid', {
          describe: 'id of the job',
          type: 'number'
        });
    },
    handler
  })
  .demandCommand(1, 'must provide a valid command')
  .option('copy', {
    default: false,
    describe: 'Write the results as markdown to clipboard'
  })
  .option('json', {
    type: 'string',
    describe: 'Write the results as json to the path'
  })
  .help()
  .argv;

async function getResults(cli, request, job) {
  let build;
  const { type, jobid } = job;
  if (type === PR) {
    build = new PRBuild(cli, request, jobid);
    await build.getResults();
  } else if (type === COMMIT) {
    build = new CommitBuild(cli, request, jobid);
    await build.getResults();
  } else if (type === BENCHMARK) {
    build = new BenchmarkRun(cli, request, jobid);
    await build.getResults();
  } else {
    yargs.showHelp();
    return;
  }
  return build;
}

async function main(command, argv) {
  const cli = new CLI();
  const credentials = await auth();
  const request = new Request(credentials);
  const queue = [];

  const commandToType = {
    'commit': COMMIT,
    'pr': PR,
    'benchmark': BENCHMARK
  };

  if (command === 'walk') {
    const type = commandToType[argv.type];
    const builds = await listBuilds(cli, request, type);
    for (const build of builds.failed) {
      queue.push(build);
    }
  } else if (command === 'url') {
    let parsed = parseJobFromURL(argv.url);
    if (parsed) {
      queue.push({
        type: parsed.type,
        jobid: parsed.jobid
      });
    } else {
      const parser = await JobParser.fromPR(argv.url, cli, request);
      if (!parser) {  // Not a valid PR URL
        return yargs.showHelp();
      }
      const ciMap = parser.parse();
      for (const [type, ci] of ciMap) {
        queue.push({
          type: type,
          jobid: ci.jobid
        });
      }
    }
  } else {
    queue.push({
      type: commandToType[command],
      jobid: argv.jobid
    });
  }

  let dataToCopy = '';
  let dataToJson = [];

  for (let job of queue) {
    cli.separator('');
    if (job.link) {
      cli.log(`Running ${job.link}`);
    } else {
      cli.log(`Running ${job.type}: ${job.jobid}`);
    }
    cli.separator('');
    const build = await getResults(cli, request, job);
    build.display();

    if (argv.copy) {
      dataToCopy += build.formatAsMarkdown();
    }

    if (argv.json) {
      dataToJson = dataToJson.concat(build.formatAsJson());
    }
  }

  if (argv.copy) {
    clipboardy.writeSync(dataToCopy);
    cli.separator('');
    cli.log(`Written markdown to clipboard`);
  }

  if (argv.json) {
    writeJson(argv.json, dataToJson);
    cli.separator('');
    cli.log(`Written JSON to ${argv.json}`);
  }
}

function handler(argv) {
  const [ command ] = argv._;
  runPromise(main(command, argv));
}
